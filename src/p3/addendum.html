
<!DOCTYPE html>
<html>
<head>
    <title>Reflecting on JavaScript Game Modifications</title>
</head>
<link rel="stylesheet" href="addendum.css">
<body>
    <h1>Explanation of Grid-Based Puzzle Game JavaScript Code</h1>
    <p>This document provides a thorough explanation of the JavaScript code used to create a grid-based puzzle game.</p>
    
    <h2>1. Initial Board Preparation</h2>
    <p>The code first identifies the 'board' element in the DOM, marking the area for gameplay. An array, 'squares', is prepared to store the square elements that will make up the game board.</p>

    <h2>2. Action: toggleSquare(index)</h2>
    <p>This function is invoked when a square is clicked and receives the index of that square. It calculates the square's position in a grid layout and identifies the adjacent squares for interaction. The function toggles the 'is-off' class on the square itself and its immediate neighbors, altering their visual state.</p>

    <h2>3. Evaluating the Game: checkGameState()</h2>
    <p>Following each interaction, this function checks whether the player has met the game's objective. It looks to see if all squares are in the 'off' state, indicated by the 'is-off' class, and calls 'displayWin()' for a victory. If certain criteria involving 'moves' and 'MAX_MOVES' are met, it signals a game over with 'displayLoss()'.</p>

    <h2>4. Notification Functions: displayWin() and displayLoss()</h2>
    <p>These functions are responsible for displaying alert messages to indicate the game's outcome.</p>

    <h2>5. Launching a New Game: newGame()</h2>
    <p>Triggers the start of a new game by invoking 'resetBoard()'.</p>

    <h2>6. Game Board Reset: resetBoard()</h2>
    <p>This function reconfigures each square's state randomly to establish a new game layout.</p>

    <h2>7. Creating the Game Grid</h2>
    <p>Through a loop, the script creates square 'div' elements, adds them to the 'board', and makes them interactive.</p>

    <h2>8. Initiation of Play</h2>
    <p>The game is set in motion with the call to 'newGame()', setting the stage for the first round.</p>

    <h1>Reflections on Modifying a JavaScript Puzzle Game</h1>

    <h2>Designing the Game</h2>
    <p>Objective: To develop a user-friendly and engaging grid-based puzzle.</p>
    <p>Design Decision: Selected a grid structure for its intuitive gameplay.</p>
    <p>Challenge: Creating a simple yet compelling game design.</p>
    <p>Solution: Randomized initial cell states to add depth to the game.</p>

    <h2>Game Mechanic Development</h2>
    <p>Goal: Establish a smooth and interactive system for cell states.</p>
    <p>Design Choice: Created an algorithm to dynamically identify adjacent cells.</p>
    <p>Difficulty: Accurate neighbor identification for border cells.</p>
    <p>Resolution: Implemented a logic based on the position of cells for assigning neighbors.</p>

    <h2>Interactive Elements</h2>
    <p>Aim: To ensure player interactions were intuitive and responsive.</p>
    <p>Innovation: Added event listeners to each cell for dynamic interactions.</p>
    <p>Challenge: Managing event listeners effectively, particularly during game restarts.</p>
    <p>Solution: Developed a system to refresh event listeners for each new game.</p>

    <h2>Defining Winning and Restart Mechanisms</h2>
    <p>Purpose: Establish clear victory conditions and enable game restarts.</p>
    <p>Approach: Defined a win condition with all cells off and added a restart option.</p>
    <p>Problem: Ensuring the game correctly resets and accurately checks for wins.</p>
    <p>Method: Implemented a victory check function and a restart mechanism.</p>

    <h2>Player Interaction and Feedback</h2>
    <p>Objective: Offer immediate and understandable feedback on game interactions.</p>
    <p>Design Approach: Used simple UI elements for feedback and win indications.</p>
    <p>Balance: Achieving a blend of simplicity and informativeness in feedback.</p>
    <p>Implementation: Adopted straightforward UI components for feedback and win alerts.</p>

    <h2>Insights from Development</h2>
    <ul>
        <li>Emphasis on the modular approach for adaptable game mechanics.</li>
        <li>The critical role of detail-oriented code modification and understanding dependencies.</li>
        <li>The necessity of thorough testing for a seamless gaming experience.</li>
    </ul>

    <p>Conclusion: The development process highlighted the intricate balance between coding precision, player engagement, and game mechanic flexibility. It showcased the significance of strategic planning and detailed testing in game development.</p>
</body>
</html>
